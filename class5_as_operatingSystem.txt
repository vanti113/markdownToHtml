# 오퍼레이팅 시스템 제5강
참조 : https://jhnyang.tistory.com/155
## **복수의 프로그램을 동시에 실행2**

1. 목적은 프로그램을 효율적으로 움직이기 위한 것. 그 방법으로서
   1. 복수의 프로그램을 **연속**해서 실행한다.
       > **연속실행**은 스케쥴러라는 프로그램이 컴퓨터에 빌트인 되어있는 체계에서, 복수의 프로그램의 실행 순서를 미리 먼저 정한 뒤, 프로그램의 실행순서 그 자체를 프로그램으로 미리 준비하고 실행하는 것이다.  이 스케쥴러는 오퍼레이팅 시스템의 선조 격이다.
   2. 복수의 프로그램을 **동시**에 실행한다.
      1. 동시실행은 복수의 프로그램을 메모리 안에 일단 불러서 준비한뒤 태스크의 실행을 반복적으로 전환해 나가는 체계이다. 이것을 멀티태스크라고 부른다. 또한 이 태스크를 전환하는 것을 **dispatch**라고 부른다.
   3. 스케쥴러는 이 연속살행과 멀티태스크를 동시에 가지고 있다.
   4. 동시실행을 한다고 해서 결단코 태스크의 실행 속도가 빨라지는 것은 아니다.
2. 태스크를 전환하는 타이밍은? 3가지가 있다.
   1. 입출력(외부기억장치나 입력장치에 의한)이 일어나거나, 혹은 입출력이 종룓히는 시점에 전환한다.
      1. >예를 들어 하드디스크에 파일을 저장한다고 치자. 하드디스크의 속도는 시피유에  비해 극단적으로 느리기때문에, 시피유는 태스크를 전환하지 않으면 그 작업이 끝날때까지 기다릴수밖에 없다. 즉, **노는 시간(Idle time)**이 발생한다. 따라서 그 손해를 방지하기 위해 시피유는 다른 태스크의 작업으로 넘어간다.
      2. >혹시 하드웨어에서 작업종료의 신호가 간다면, 시피유는 현재의 태스크 실행을 일단 멈추고 전의 작업으로 돌아간다. 결국 아이들타임, 즉 입출력대기시간을 이용하여 다른 태스크를 처리하는 것, 이것이 동시실행의 핵심이다.
    2. 태스크가 스스로 CPU의 사용권을 다른 태스크에 전달한다.
       1. ノンプリエンプティブマルチタスクnone-preemptive??
          1. > 태스크의 실행 중간에 끼어들수가 없는, 즉 독점의 상태를 가리킨다.  
    3. 일정시간이 되면(별도로 존재하는 타이머에 의해), 강제적으로 태스크 전환(디스패치)를 한다. 이것을 preemptive プリエンプティブ라고 함.
        >이것으로 인해 태스크가 무한루프에 빠지거나 하는 일이 없어진다. 타임슬라이스(적절히 배분된 태스크 시간)마다 전환하게 된다.
## **태스크의 전환순서**
### 태스크 스케쥴링 알고리즘 in 라운드로빙 방식

1. 라운드로빙 방식ラウンドロビン方式
   1. 컴퓨터의 효율면에서 보면 별로 좋지 않다.
2. 태스크의 종류
   1. 대화형
      1. >워드나 엑셀등 유저의 입력에 대해, 그때그때 반응하고 결과를 출력하는 타입
   2. 배치형batchバッチ(일괄처리를 의미함) 
      1. >3DCG렌더링같이 처리시작 전에 필요한 데이터를 준비해 두고, 모든 결과가 나올때 까지 유저가 끼어들지 않는 타입?? 처리 도중에 끼어들수가 없다.
3. 태스크의 종류와 전환
   1. >라운드로빙의 나쁜 점은 가령 시피유가 메모리에 안에서 실행해야할 태스크들이 중간에 개입이 가능한 대화형이 아닌 바치형태의 태스크라면, 그 태스크가 실행되는 동안에는 유저가 입력을 할수가 없기 때문에 조작성이 나빠진다.
   2. >이것을 어떻게 개선할까? **우선도**에 관한 이야기가 된다. 우선도를 사용하여 태스크스케쥴링을 하게 되면, 하나하나의 태스크에 우선도를 정하게 된다. 따라서 우선도가 높은 태스크 예를 들면 대화형 태스크에 우선도 고를 지정하여 더 자주 실행하게 되고 조작성이 높아진다.
4. 프로세스 테이블
   1. >태스크에 관련된 정보 테이블을 준비하여, 이것을 메모리의 빈 공간에 보존, 그 정보에는 상태, 우선도, cpu시간 같은 정보도 기입되어 있어서 스케쥴러가 이것을 보고 확인하여 실행 순서을 결정한다. cpu실행시간 이란 것도 있어서 CPU에 의한 실행누계시간등으로 판단하여 누계가 적은 태스크를 우선적으로 실행하기도 한다.
5. 프로세스(태스크)의 상태
   1. >간단히 이야기 하면 지금 cpu가 실행중인 태스크의 상태, 즉 실행중 인가(시피유가 할당된 상태)  실행가능(태스크에 관한 입출력이 종료된 상태)인가 슬립상태(시피유가 할당되고 난뒤 무언가의 실행을 위한 입출력을 대기중)인가 하는 것들이다.
   2. 실행가능 상태 ->(디스패치)->실행중 상태 ->(입출력이 발생하여 다른 태스크로 전환)->슬립상태로 대기->입출력이 종료 -> 실행가능 상태 
   3. 실행가능 상태와 슬립상태의 가장 큰 차이점은 실행가능 상태는 시피유만 할당받으면 언제라도 실행중으로 넘어갈수 있지만, 슬립상태는 입출력이 종료되기 전까지는 태스크 전환 디스패치가 되지 않는다.
   4. 프로그램을 종료하면 그 태스크는 바로 사라지는 것이 아닌, 메모리의 안에서 후처리後片付け를 기다리는 상태가 된다.　이것을 ゾンビ라고 한다. 말그대로 좀비. 후처리가 가능한 상태가 되면 이 좀비태스크들은 메모리에서 삭제된다. 

## **멀티스레드**
### 디스패치, 즉 태스크 전환에도 시간이 걸린다. 때문에 생긴 개념.
1. 멀티태스크란 하나의 태스크안에 프로그램을 복수의 스레드로 분할해 둔다음, 오퍼레이팅시스템이 먼저 몇개의 스레드가 존재하는 가를 확인 한 뒤, 멀티태스크같이 실행시킨다. 즉, 하나의 태스크를 다수의 실행단위로 나눠서 동시실행을 시키는 것이다. 이때 스레드는 시피유의 레지스터를 할당받아서 사용한다.